# STL源码剖析 - 全排列相关（permutation）

全排列即列举出给定元素的排列组合情况。根据数学上的原理，对于有`n`个不重复的元素的集合，其排列组合的结果有`n!`种情况。因此，全排列的算法在时间复杂度上是`O(n!)`的。

## 基础实现

最常规的实现全排列的方式是递归。假设有`n-1`个元素的全排列，对于其中任意一种排列情况来说，再添加一个新元素，都会增加`n`种排列（即新元素分别放置在第`1`个位置到第`n`个位置，总共`n`种情况）。

以此为基础，可以将`n`个元素的全排列视为`n-1`个元素的全排列扩展而来，而第`n`个元素可以通过交换来放在不同的位置。

代码如下：

```cpp
void permutation(vector<int>& vec, int m) { // vec元素集合，m当前全排列数据的位置，此时需要排列的数据为[m,n)，m从0开始
  if (vec.empty()) return;
  const int n = vec.size();
  if (m == n) { // 排列到了最后的位置，输出一种结果
    for (int v : vec) cout << v << ' ';
    cout << endl;
  } else {
    for (int i = m; i < n; ++i) {
      swap(vec[i], vec[m]);    // 列举出第m个数据为每个元素的情况
      permutation(vec, m + 1); // 固定了第m个元素，对[m+1,n)进行全排列
      swap(vec[i], vec[m]);    // 恢复原来的顺序
    }
  }
}
```

## 去重

上面的这种实现的前提是集合中元素不重复，否则会列出冗余的排列。如何在有重复的集合中进行全排列？重点就是去除重复的排列情况。

对于两个相同的元素来说，如`vec[i]`和`vec[j]`，第`i`个元素进行交换之后产生全排列，和第`j`个元素进行交换的全排列，结果是一样的。因此，同样数值的元素，只需要交换、递归全排列一次即可。

只需要判断第i个元素之前是否存在相同的元素，如果存在则不需要再进行交换和递归。具体的实现可以是用for循环来逐一判断；或者是时间换空间，通过`unordered_set`来判断。


```cpp
void permutation(vector<int>& vec, int m) {
  if (vec.empty()) return;
  const int n = vec.size();
  if (m == n) {
    for (int v : vec) cout << v << ' ';
    cout << endl;
  } else {
    unordered_set<int> s;
    for (int i = m; i < n; ++i) {
      if (s.find(vec[i]) != s.end()) continue;
      swap(vec[i], vec[m]);
      permutation(vec, m + 1);
      swap(vec[i], vec[m]);
      s.insert(vec[i]);
    }
  }
}
```

## 非递归形式

以上是通过递归的方式实现全排列，非递归方式有待补充。

## 下一个排列

如果全排列集合中的元素有优先级，则全排列的所有情况也会从在优先级的差别。例如集合为`{1,2,3}`，则全排列按照优先级（即整数的大小）从小到大的顺序为`123`->`132`->`213`->`231`->`312`->`321`。下一个排列即在该优先级顺序下的下一个全排列。对于`123`来说，就是`132`。

## 参考文章
1. [详解全排列](https://www.cnblogs.com/sooner/p/3264882.html)
2. [全排列算法的理解与实现（递归+字典序）](https://www.jianshu.com/p/50a27d7d2972)
3. [全排列问题——浅谈递归](https://blog.csdn.net/guogangj/article/details/1430090)
