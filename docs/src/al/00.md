# 单调栈和单调队列

普通的栈和队列自不必多说；C++ STL也有很方便的配接器`stack`和`queue`供编程使用。单调栈和单调队列，则是在栈和队列的基础上，添加特定的条件控制`push`和`pop`操作，从而实现特定的目的，下面根据力扣上的题目来分析一下。

## 单调栈
[LeetCode 739 每日温度](https://leetcode-cn.com/problems/daily-temperatures/)

> 请根据每日 气温 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。<br>
例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。<br>
提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。

简而言之，就是找到每个元素后面的大于该元素的第一个位置。当然最直接的思路就是每一个元素都向后找一次，直到找到比它大的那个停止，时间复杂度为 $O(N^2)$，显然不是最佳的解法。

依次遍历每个数字，如果当前的数字大于前一个数字，那么当前的数字就是前一个数字的解；如果小于，则当前数字与前一个数字都处于没有找到解的状态，直到出现一个更大的数字，例如71 69 72这三个数字，遍历到72时已经可以输出前两个位置的解。

在以上思路的基础上，维护一个单调递减的栈，出现遍历到新的数据，和栈顶相比，如果大于栈顶元素，则该数字为栈顶元素的解，栈顶出栈再次判断，直到栈顶大于该数字或栈为空，该数字进栈。

好吧，感觉还是说的不怎么清楚，直接写代码更好一些：

```cpp
vector<int> dailyTemperatures(vector<int>& temperatures) {
  const int n = temperatures.size();
  vector<int> ans(n, 0);
  stack<int> st;
  for (int i = 0; i < n; ++i) {
    while (!st.empty() && temperatures[st.top] < temperatures[i]) {
      ans[st.top()] = i - st.top();
      st.pop();
    }
    st.push(i);
  }
  return ans;
}
```

通过`stack`存下标的方式，能够更好地计算下标的差。

## 单调队列
[LeetCode 239 滑动窗口最大值](https://leetcode-cn.com/problems/sliding-window-maximum/)

> 给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。<br>
返回滑动窗口中的最大值。<br>
示例 1：<br>
输入：nums = [1,3,-1,-3,5,3,6,7], k = 3<br>
输出：[3,3,5,5,6,7]<br>
解释：<br>
滑动窗口的位置 &nbsp;                      最大值<br>
[1  3  -1] -3  5  3  6  7  &nbsp;&nbsp;&nbsp; 3   
 1 [3  -1  -3] 5  3  6  7  &nbsp;&nbsp;&nbsp; 3   
 1  3 [-1  -3  5] 3  6  7  &nbsp;&nbsp;&nbsp; 5   
 1  3  -1 [-3  5  3] 6  7  &nbsp;&nbsp;&nbsp; 5   
 1  3  -1  -3 [5  3  6] 7  &nbsp;&nbsp;&nbsp; 6   
 1  3  -1  -3  5 [3  6  7] &nbsp;&nbsp;&nbsp; 7   

---

