# 各种排序算法

~~准备用通过模板来实现各种排序算法，并编译为动态链接库，作为练习。~~

虽然出发点很好，但想法太天真。经过编译测试后发现，模板类的代码是无法编译成库的（无论动态静态），更准确的说是编译出的库无法使用。
> 要把模板做成库供外部使用，应该提供头文件。阅读[Standard C++](https://isocpp.org/wiki/faq/templates#templates-defn-vs-decl)。

> libstdc++虽然包含了STL实现，但STL部分是头文件提供的；动态库里包含的是C++运行时的相关代码（如异常处理、name decoration等相关API）。

> **模板只有在特化的时候，才由编译器帮你生成特定的代码。**

基于以上的原因，即使编译出了包含模板实现的库，在主程序链接时，也会报错找不到函数定义。最初还以为是自己的模板参数有问题，推导不出类型。还是没有理解到问题的本质😭

## 准备工作
动态链接库的编译：
- 将类的声明、函数的声明放在一个头文件中
- 相应的类、函数的实现放在其他源文件中，作为被编译的源文件

运行编译命令：
```bash
g++ mysort.cpp -fPIC -shared -o libmysort.so
```
就能生成动态链接库文件libmysort.so。参数说明：
- `-shared`：该选项指定生成动态连接库
- `-fPIC`：表示编译为位置独立的代码，不用此选项的话编译后的代码是位置相关的所以动态载入时是通过代码拷贝的方式来满足不同进程的需要，而不能达到真正代码段共享的目的。

编译目标文件时使用动态链接库：
```bash
g++ main.cpp -L. -lmysort -o main
```
`-L`和`-l`分别指定库的位置（当前路径）和库（mysort）的名称。可以通过`ldd main`来查看目标文件中的链接情况：
```bash
$ ldd main
        linux-vdso.so.1 (0x00007fffe22a8000)
        libmysort.so => not found
        libstdc++.so.6 => /usr/lib/x86_64-linux-gnu/libstdc++.so.6 (0x00007fa94bbb0000)
        libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007fa94b7b0000)
        libm.so.6 => /lib/x86_64-linux-gnu/libm.so.6 (0x00007fa94b410000)
        /lib64/ld-linux-x86-64.so.2 (0x00007fa94c200000)
        libgcc_s.so.1 => /lib/x86_64-linux-gnu/libgcc_s.so.1 (0x00007fa94b1f0000)
```
发现libmysort.so的路径找不到，这样的目标文件在执行时会报找不到动态链接库（cannot open shared object file）的问题。两篇参考文章都提到了几种解决方案，其中，最实用且不会修改系统设置的方案：

在编译目标程序时，使用`-Wl,-rpath`对动态链接库的路径进行补充，即：
```bash
g++ main.cpp -L. -lmysort -o main -Wl,-rpath=/home/mylibpath
```
这样再通过`ldd main`检查目标文件的链接情况时，libmysort.so已经有具体的路径。

参数说明：
- `-Wl` 编译器将后面的参数传递给链接器ld，注意W是大写的
- `-rpath` 添加一个路径作为运行时库的搜索路径，链接时会优先搜索提供的路径

## 排序算法合集
虽然上面的想法失败了，但排序算法还是要练习，下面依次列出常见的排序算法。
### 冒泡排序
相当基础。核心思想是通过交换，将最大值（最小值）逐步移动到数据的一端，每次完成一个数据的移动。
```cpp
void bubble_sort(vector<int>& v) {
  const int n = v.size();
  for (int i = n - 1; i >= 0; --i) // 从后向前，先将大的元素放在尾端
    for (int j = 0; j < i; ++i)
      if (v[j] > v[j + 1])
        swap(v[j], v[j + 1])
}
```
时间复杂度 $O(n^2)$  空间复杂度 $O(1)$ 稳定排序
### 选择排序
核心思想是每次扫描选择出当前序列中的最小值（最大值），与数据的一段进行交换，使得一段逐渐变得有序。
```cpp
void select_sort(vector<int>& v) {
  const int n = v.size();
  for (int i = 0; i < n; ++i) {
    int k = i;
    for (int j = i; j < n; ++j) // 选取从i开始到尾部中最小的那个元素位置k，与i交换
      if (v[j] < v[k]) k = j;
    swap(v[i], v[k]);
  }
}
```
时间复杂度 $O(n^2)$ 空间复杂度 $O(1)$ 不稳定排序

[一个例子证明不稳定](https://blog.csdn.net/houyanjun/article/details/2446074)
### 插入排序
核心思想是将数据分为已排序部分和未排序部分，扫描未排序部分的数据，插入到已排序数据的合适位置。
```cpp
void insert_sort(vector<int>& v)
  const int n = v.size();
  for (int i = 0; i < n; ++i) {
    for (int j = i; j > 0; --j)
      if (v[j] < v[j - 1])
        swap(v[j], v[j - 1]); // 通过不断交换的方式将i位置的数据插入到前面合适的位置
      else break;
}
```
时间复杂度 $O(n^2)$  空间复杂度 $O(1)$ 稳定排序

**注意**：数组的插入是要数据向后移动的，因此从后向前找合适的位置，通过交换的方式实现数据的后移。

这里也会提到**折半插入排序**，折半这个操作体现在查找合适位置上，通过折半查找的方式，查找到未排序数据应该插入的位置，折半查找的时间复杂度为$O(logn)$。然而对于数组来说，插入后的移动操作时间复杂度还是$O(N)$，因此整体的时间复杂度不变，还是$O(N^2)$。
### 希尔排序
又称**缩小增量排序**，是插入排序的改进。先将整个数据分组，每组的长度即为“增量”，对每组内的数据分别进行插入排序，完成后再逐步减小增量，再进行插入排序；直到增量缩减为1，最后一次插入排序。

相比于插入排序，每次扫描分段的操作，能够提升一些效率。

时间复杂度 $O(n^2)$  空间复杂度 $O(1)$ 不稳定排序

### 堆排序
利用大顶堆（小顶堆）的特性，先将数据建堆，再将数据出堆，数据就变得有序了。

每个数据出堆、入堆的时间复杂度都是$O(logn)$。

时间复杂度$O(nlogn)$ 空间复杂度$O(1)$ 不稳定排序

### 归并排序
如果是两个有序链表合并的话，归并排序就变得非常直观，每次选择两个链表表头相对小（大）的那个作为新的数据。

对于一个数组来说，就是自底向上的过程。首先是单个数据作为已经排序的数据进行合并；在已经合并的数据基础上，在进行两两合并；直到最终分组消失，所有数据都进行了合并。


时间复杂度$O(nlogn)$ 空间复杂度$O(n)$ 稳定排序
### 快速排序

### 计数排序

### 桶排序

### 基数排序


## 参考文章
1. [gcc/g++实战之动态链接库与静态链接库编写](https://www.cnblogs.com/zjiaxing/p/5557629.html)
2. [运行时动态库：not found 及介绍-Wl,-rpath](https://blog.csdn.net/weixin_37139197/article/details/78736291)
3. [C++中，能够把模板封装成库吗？怎么做？](https://www.zhihu.com/question/62066980)
4. [面试官爱问的10大经典排序算法，20+张图来搞定](https://mp.weixin.qq.com/s/DjpZUEniizUj-XEZI8Qq-Q)
